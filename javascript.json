{
	// Place your snippets for javascript here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"axios+mult":{
		"prefix": "axios+mult",
		"body": [
			"const http = require('http');const url = require('url');const multiparty = require('multiparty')",
"let server = http.createServer((req, res) => {",
"if (req.method === 'POST') {if (url.parse(req.url).pathname === '/upload') {",
"let form = new multiparty.Form({ uploadDir: './static' })",
"form.parse(req, function (err, fields, files) {res.writeHead(200, { 'content-type': 'multipart/form-data' });",
"res.end('received upload:\n\n');});} }})server.listen(5000)",
"",
"const axios = require('axios') const FormData = require('form-data');",
"const form = new FormData(); const fs = require('fs');",
"form.append('file', fs.createReadStream('./data.json'));  ",
"axios({method: 'post',url: 'http://localhost:5000/upload',headers: form.getHeaders(),data: form",
"}).then(function (response) {console.log('file upload')});",
		],
		"description": "Write Stream"
	},
	"upload_form":{
		"prefix": "upload_form",
		"body": [
			"var http = require('http');var formidable = require('formidable');var fs = require('fs');",
		"http.createServer(function (req, res) {if (req.url == '/fileupload') {",
		"var form = new formidable.IncomingForm();",
		"form.parse(req, function (err, fields, files) {",
		"var oldpath = files.filetoupload.filepath;",
		"var newpath = './upload/' + files.filetoupload.originalFilename;",
		"fs.copyFile(oldpath, newpath, function (err) {",
		"if (err) throw err;res.write('File uploaded and moved!');res.end();",
		"});});} else {res.writeHead(200, {'Content-Type': 'text/html'});",
		"res.write('<form action='fileupload' method='post' enctype='multipart/form-data'>');",
		"res.write('<input type='file' name='filetoupload'><br>');",
		"res.write('<input type='submit'>');",
		"res.write('</form>');return res.end();}}).listen(8080);",
		"По сути, formidable делает форму, отправленную через HTTP POST, доступной для парсинга в Node.js. Все что нам надо, это создать новый экземпляр объекта IncomingForm, который является абстракцией отправленной формы и который может быть использован для парсинга объекта request нашего HTTPсервера, для полей и файлов, отправленные через эту форму."
		],
		"description": "Write Stream"
	},
	"upload_OPEN":{
		"prefix": "upload_OPEN",
		"body": [
			"var http = require('http');var url = require('url');var fs = require('fs');let mp=require('multiparty');",
		"let writeHTTP405=(res)=>{res.writeHead(405, {'Content-Type' : 'text/plain; charset=utf-8'});res.end('Method not allowed');}",
		"const MIME = {HTML: Symbol('text/html; charset=utf-8'),JS: Symbol('text/javascript'),PNG: Symbol('image/png'),};",
		"res404 = (res, url, mime) => {const statusCode = 404;res.writeHead(statusCode, getHeader(mime));res.end(`Error ${statusCode}<br>Url: ${url}`);}",
		"let http_handler=(req,res)=>{if(req.method=='GET'){",
		"if (url.parse(req.url).pathname === '/') {res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});res.end(fs.readFileSync('i.html'));}",
		"else if(url.parse(req.url).pathname.slice(1).split('/')[0] === 'files'){",
		"let arrayPath = url.parse(req.url).pathname.slice(1).split('/');let fileName = arrayPath[1];",
		"If (fs.existsSync(`./static/${fileName}`)) {fs.access(`./static/${fileName}`, fs.constants.R_OK, () => {res.writeHead(200, {'Content-Type': 'application/txt; charset=utf-8'}); fs.createReadStream(`./static/${arrayPath[1]}`).pipe(res);});",
		"} else {res404(res, request.url, MIME.HTML);} }}else if(req.method=='POST'){if(url.parse(req.url).pathname=== '/upload'){",
		"let result='';let form =new mp.Form({uploadDir:'./static'});form.on('field',(name,value)=>{result+=`${name}= ${value}<br/>`;});",
		"form.on('file', (name, file)=>{result+=`${name}= ${file.originalFilename}: ${file.path}<br/>`;});",
		"form.on('error',(err)=> {res.writeHead(200, {'Content-Type':'text/html;charset=utf-8'});res.write('Form/error: '+err);res.end()});",
		"form.on('close',()=>{res.writeHead(200, {'Content-Type':'text/html;charset=utf-8'});res.write('Form<br/>');res.end(result);})form.parse(req);}}else writeHTTP405(res);}",
		"var server=http.createServer(function (req, res){http_handler(req,res);}).listen(5000, () => {console.log('http://localhost:5000/files/pic.png');console.log('http://localhost:5000/');});",
		"",
		"<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'>",
		"<meta name='viewport' content='width=device-width, initial-scale=1.0'>",
		"<title>Uploader</title></head><body>",
		"<form action='http://localhost:5000/upload' method='POST' enctype='multipart/form-data'>",
		"<input name='file'  type='file' /><br/><input name='upload' type='submit' value='send'/>",
		"</form></body></html>",],
		"description": "Write Stream"
	},
	"wStream":{
		"prefix": "wStream",
		"body": [
			"const fs = require('fs');",
            "const WebSocket = require('ws');",
            "const wss = new WebSocket.Server({port:4000, host:'localhost'});",
            "let k = 0;",
            "wss.on('connection', (ws)=>{ ",
            "const duplex = WebSocket.createWebSocketStream(ws, {encoding: 'utf8'});",
            "let wfile = fs.createWriteStream(`./upload/1-${++k}.txt`);", 
			"duplex.pipe(wfile); ",
			"",
			"const fs = require('fs');",
			"const WebSocket = require('ws');",
			"const ws = new WebSocket('ws://localhost:4000');",	
			"ws.on('open', ()=>{",
			"const duplex = WebSocket.createWebSocketStream(ws, {encoding: 'utf8'});",
			"let rfile = fs.createReadStream(`./1.txt`); ",
			"rfile.pipe(duplex); //запись в поток",
			"});"
		],
		"description": "Write Stream"
	},
	"udp2":{
		"prefix": "udp",
		"body": [
		"const udp = require('dgram');",
		"const server = udp.createSocket('udp4');",
		"server.on('message', (msg, rinfo) => {console.log(msg.toString(), rinfo.address, rinfo.port);",
		"server.send('echo '+ msg, rinfo.port, rinfo.address );});",
		"server.bind(5000);",
		"",
		"const udp = require('dgram');",
		"const client = new udp.createSocket('udp4');",
		"process.stdin.on('data', (data) => {client.send(data.toString(), 5000, 'localhost');});",
		"client.on('message', (msg) => {console.log(msg.toString());client.close();});",
		],
		"description": "Write Stream"
	},
	"wHTML":{
		"prefix": "wHTML",
		"body": [
		"const WebSocket = require('ws')",
		"let WebSocketServer = new WebSocket.Server({port: 4000, host: 'localhost'}, {transports: ['websocket']})",
		"WebSocketServer.on('connection', ws => {console.log('connected') ",
		"ws.on('message', msg => { console.log(msg.toString())",
		"WebSocketServer.clients.forEach(client => {",
		"if (client.readyState === WebSocket.OPEN && client !== ws) {client.send(msg.toString())}})})})",
		"",
		"let fs = require('fs') let http = require('http')",
		"let server = http.createServer(function(request, response) {",
		"let body = fs.readFileSync('./index.html')",
		"response.writeHead(200, {'Content-Type': 'text/html'})",
		"response.end(body)}).listen(3000)",
		"",
		"<!DOCTYPE html><html><head></head><body>",
		"<input type='text' id='message'>",
		"<button onclick ='Fd()''>Send</button>    ",
		"</body><script>",
		"let socket = new WebSocket('ws://localhost:4000');",
		"function Fd() {let outgoingMessage = document.getElementById('message').value;",
		"socket.send(outgoingMessage);};",
		"socket.onmessage = function (event) {console.log(event.data)}",
		"</script></html>",
		],
		"description": "Write Stream"
	},
	"ax1":{
		"prefix": "ax1",
		"body": [
			"const http = require('http');const fs = require('fs');",
"const server = http.createServer((req, res) => {let data = '';",
"if(req.method === 'POST' && req.url === '/') {",
"req.on('data', chunk => {data += chunk;});",
"req.on('end', () => {fs.writeFileSync('./2.json', data); res.end('OK');});}}).listen(3000);",
"",
"const axios = require('axios');const fs = require('fs');",
"axios({url: 'http://localhost:3000',method: 'POST',data: fs.readFileSync('./1.json')})",
".then (res => {console.log(res.data);}).catch(err => { console.log(err) });",
		],
		"description": "Write Stream"
	},
	"ax2":{
		"prefix": "ax2",
		"body": ["const http = require('http');const fs = require('fs');",
		"const server = http.createServer((req, res) => { ",
		"if(req.method === 'GET' && req.url === '/') {",
		"let file = fs.readFileSync('./2.json'); res.write(file);}}).listen(3000);",
		"",
		"axios = require('axios');const fs = require('fs');",
"axios({url: 'http://localhost:3000/',method: 'GET'})",
".then (res => { fs.writeFileSync('./1.json',res.data);}).catch(err => { console.log(err) });",
		],
		"description": "Write Stream"
	},

	"w1":{
		"prefix": "w1",
		"body": [
			"var WSServer = require('ws');",
			"var server = new WSServer.Server({ port: 3000, host: 'localhost' , path: '/ws' })",
			"server.on('connection', (ws) => {",
			"ws.on('message', message  =>{console.log(message.toString());",
			"server.clients.forEach(el => {el.send(message);})})});",
			"",
			"const ws = require('ws');  ",
            "let client = new ws('ws://localhost:3000/ws');",
			"client.on('open', () =>{",
			"process.stdin.on('data', data=> { ",
			"let ff = ws.createWebSocketStream(client, {encoding: 'utf8'});",
			"ff.write(data.toString())}).unref();});",
			"client.on('message',(data)=> {console.log(data.toString());}); ",
			"setTimeout(() => {client.close();}, 20 * 1000)",
		],
		"description": "Write Stream"
	},

	"x-ww2":{
		"prefix": "x-ww2",
		"body": [
			"const http = require('http');",
"const fs = require('fs');",
"const query = require('querystring');",
"const server = http.createServer((req, res) => {let body = '';",
"req.on('data', (chunk) => {body += chunk.toString();});",
"fs.open('1.json', 'w', (err, fd) => {",
"let f = JSON.stringify(query.parse(body));if (err) throw err;",
"fs.appendFile(fd, f, (err) => {if (err) throw err;fs.close(fd, (err) => {if (err) throw err; });",
"});});}).listen(3000);",
"",
"const http = require('http');",
"const query = require('querystring');",
"const param = query.stringify({x: 2, y: 8, s: 'aa'});",
"const options = {hostname: 'localhost',port: 3000,path: '/',method: 'POST',headers: {'Content-Type':'application/x-www-form-urlencoded'}};",
"let request = http.request(options, (res) => { console.log('Response status: ',res.statusCode); ",
"let data= ''; res.on('data', (chunk) => {console.log('body: ',data += chunk.toString('utf8'));});}); ",
"request.write(param); request.end();",
		],
		"description": "Write Stream"
	},

	"wBroadcaaste":{
		"prefix": "wBroadcaaste",
		"body": [
			"const WebSocket = require('ws');",
            "const wss = new WebSocket.Server({port: 4000, host: 'localhost', path: '/broadcast'});",
            "wss.on('connection', ws => {",
            " console.log('Connected');",
            "ws.on('message', message => {",
            "  wss.clients.forEach(client => {",
            "  if(client.readyState === WebSocket.OPEN) ",
            "client.send('server: ' + message);",
            "    });",
            " });",
            " });",
            "wss.on('error', e => {console.log('error wsServer', e)});",
            "",
			"const WebSocket = require('ws');",
            "const ws = new WebSocket('ws://localhost:4000/broadcast'); ",
            "let timer = null;",
			"var parm = process.argv[2];",
			"let prfx = typeof parm == 'undefined' ? 'B' : parm;",
			"ws.on('open', () => {",
			"console.log('socket.open');",
			"  ws.on('message', (e) => {console.log(`${e}`);});",
			"let k = 0;",
			"timer= setInterval(() => {",
			"ws.send(`client ${prfx}-${++k}`);",	
			" }, 2000);" ,
            " setTimeout(() => { ",
			"         clearInterval(timer);",
			"   ws.close();",
			"console.log('Close'); ",
			" }, 25000)",
			"});"
		],
		"description": "Write Stream"
	},
	
	"wSockHTML":{
		"prefix": "wSocketHTML",
		"body": [
			"--server.js--",
			"const httpserver = http.createServer((req, res) => {",
			"if(req.method == 'GET' && req.url == '/start') {",
			"res.writeHead(200, {'Content-Type' : 'text/html; charset=utf-8'});" ,
			"res.end(fs.readFileSync('10-1.html'));}",
			"else {",
			"res.writeHead(400, {'Content-type': 'text/plain'});",
			"res.end('400 error');}});",
			"httpserver.listen(3000);",
			"console.log ('http://localhost:3000/start')",		
			"var k = 0, n = 0;",
			"const wss = new WebSocket.Server({port: 4000, host: 'localhost', path: '/wsserver'});",
			"wss.on('connection', ws => {" ,
			"console.log('Connected');",
			"ws.on('message', message => { ",
			"n = String(message).substr(13) ;",
			"console.log(`${message}`);}); ",
			"setInterval(() => {ws.send(`10-01-server: ${n}->${++k}`)}, 5000);}); ",
			"wss.on('error', e => {console.log('error wsServer', e)});", 
			"",
			"--client.html--",
			"<body>" ,
			"<h1>10-01</h1> ",
			"<div id='messages'></div> ",
			"<button onclick='startWS()'>startWS</button> ",
			"</body> ",
			"<script> ",
			"let n = 0; ",
			"let timer = null; ",
			"function startWS() { ",
			"let socket = new WebSocket('ws:/localhost:4000/wsserver'); ",
			"let sender; ",
			"let messages = document.getElementById('messages') ",
			"let str = ''; ",
			"socket.onopen = () => { ",
			"let n = 0 ",
			"sender = setInterval(() => socket.send(`10-01-client: ${++n}`), 3000)}",
			"socket.onmessage = (message) => { ",
			"str += message.data; ",	
			"str += '</br>'; ",
			"messages.innerHTML = str ", 
			"console.log(message.data)} ",
			"socket.onclose = (e) => {console.log('socket.onclose', e);} ", 
			"socket.onerror = (error) => {console.log(error.message);} ",
			"setInterval(() => { ",
			"clearInterval(sender); ",
			"socket.close(); ",
			"n = 0; ",
			"}, 25000)} ",
			"</script>"
		],
		"description": "Write Stream"
	},

	"wSockJS":{
		"prefix": "wSocketJS",
		"body": [
			"--server.js--",
			"const httpserver = http.createServer((req, res) => {",
			"if(req.method == 'GET' && req.url == '/start') {",
			"res.writeHead(200, {'Content-Type' : 'text/html; charset=utf-8'});" ,
			"res.end(fs.readFileSync('10-1.html'));}",
			"else {",
			"res.writeHead(400, {'Content-type': 'text/plain'});",
			"res.end('400 error');}});",
			"httpserver.listen(3000);",
			"console.log ('http://localhost:3000/start')",
			"var k = 0, n = 0;",
			"const wss = new WebSocket.Server({port: 4000, host: 'localhost', path: '/wsserver'});",
			"wss.on('connection', ws => {" ,
			"console.log('Connected');",
			"ws.on('message', message => { ",
			"n = String(message).substr(13) ;",
			"console.log(`${message}`);}); ",
			"setInterval(() => {ws.send(`10-01-server: ${n}->${++k}`)}, 5000);}); ",
			"wss.on('error', e => {console.log('error wsServer', e)});", 
			"",
			"--client.js--",
			"const WebSocket = require('ws'); ",
			"const ws = new WebSocket('ws:/localhost:4000/wsserver'); ",
			"let n = 0; ",
			"let timer = null; ",
			"ws.on('open', () => { ", 
			"console.log('socket.open'); ",
			"ws.on('message', (e) => {console.log(`${e}`);}); ",
			"timer = setInterval(() => {ws.send(`10-01-client: ${++n}`);}, 3000); ",
			"setTimeout(() => { ",
			"clearInterval(timer); ", 
			"n = 0;  ",
			"console.log('close connection');  ",
			"ws.close(); ",
			"} ,25000); ",
			"});",
		],
		"description": "Write Stream"
	},

	"Ping/Pong":{
		"prefix": "PingPong",
		"body": [
			"--server.js--",
			"const WebSocket = require('ws'); ",
			"const wss = new WebSocket.Server({port:4000, host:'localhost', path:'/'}); ",
			"let k = 0; ",
			"wss.on('connection', (ws) => {  ",
			"ws.on('pong', (data) => {console.log('on pong: ', data.toString()); }); ",
			"setInterval(() => {ws.send(`11-03-server: ${++k}`)}, 15000); ",
			"setInterval(() => { ",
			"console.log(wss.clients.size); ",
			"ws.ping('server: ping');}, 5000);}); ",
			"wss.on('error', (e) => { console.log('error ', e) }); ",
			"",
			"--client.js--",
			"const WebSocket = require('ws');" ,
			"const ws = new WebSocket('ws://localhost:4000/'); ",
			"ws.on('pong', (data) => {console.log('on pong: ', data.toString()); }); ",
			"ws.on('message', (data) => {console.log('on message: ', data.toString()); }); ",
			"setInterval(() => {  ",
			"console.log('client ping'); ",
			"ws.ping('client ping')}, 5000); ",
		],
		"description": "Write Stream"
	},

	"tcpECHO":{
		"prefix": "tcpECHO",
		"body": [
			"--server.js--",
			"const net = require('net') ", 
			"const PORT = 4000; ",
			"net.createServer((socket) => { ",
			"socket.on('data', (data) => { ",
			"console.log(data.toString())  ",
			"socket.write(`ECHO: ${data}`) }) ",
			"socket.on('error', (err) => { console.log(`${err}`);}) ",
			"}).listen(PORT , () => {console.log(`Server listening on port ${PORT}`)}) ",
			"",
			"--client.js--",
			"const net = require('net') ",
			"const HOST = '127.0.0.1' ",
			"const PORT = 4000 ",
			"let client = new net.Socket();" ,
			"client.connect(PORT, HOST, () => {console.log(`Client connected to a server`);}); ",
			"client.write('Hello from client') ",
			"client.on('data', data => { ",
			"console.log(`Client received: ${data.toString()}`); ",
			"client.destroy();}); ",
			"client.on('close', () => {console.log('Client closed');}); ",
			"client.on('error', (err) => { console.log(`${err}`);})",
		],
		"description": "Write Stream"
	},

	"udpECHO":{
		"prefix": "udpECHO",
		"body": [
			"--server.js--",
			"const dgram = require('dgram')", 
			"const PORT = 4000; ",
			"let server = dgram.createSocket('udp4')",
			"server.on('message', (msg, info) => {",
			"console.log(`${msg}`) ",
			"server.send(`ECHO: ${msg}`, info.port) }) ",
			"server.on('error', (err) => { console.log(`${err}`);})",
			"server.bind(PORT) ",
			"",
			"--client.js--",
			"const dgram = require('dgram') ",
			"const PORT = 4000 ",
			"let client = dgram.createSocket('udp4')" ,
			"client.connect(PORT, () => {client.send('Hello from client')})",
			"client.on('message', (msg, info) => {console.log(`${msg}`); client.close()})",
			"client.on('close', () => {console.log('Client closed');});",
			"client.on('error', (err) => { console.log(`${err}`);})",
		],
		"description": "Write Stream"
	},

	"tcpOtherUsers":{
		"prefix": "tcpOtherUsers",
		"body": [
			"--server.js--",
			"const net = require('net');",
			"let PORT = 4000;",
			"let sum = 0;",
			"let connections = new Map();",
			"let buffer = Buffer.alloc(4);",
			"let i=0;",
			"net.createServer((socket) => {",
			"socket.id = i++;",
			"connections.set(socket.id, 0);",
			"socket.on('data', (data) => {",
			"console.log(`${data.readInt32LE()}`);",
			"sum = data.readInt32LE() + connections.get(socket.id);",
			"connections.set(socket.id, sum);",
			"sum = 0;});",
			"let writer = setInterval(() => {",
			"buffer.writeInt32LE(connections.get(socket.id), 0);",
			"socket.write(buffer);}, 5000);",
			"socket.on('close', data => {clearInterval(writer);connections.delete(socket.id);});", 
			"socket.on('error', (e) => { connections.delete(socket.id);});}).listen(PORT);",
			"",
			"--client.js--",
			"const net = require('net')",
			"const PORT = 4000",
			"let client = new net.Socket()",
			"let buffer = new Buffer.alloc(4);",
			"let num = isNaN(process.argv[2]) ? process.exit() : process.argv[2];",
			"client.connect(PORT, () => {setInterval(() => {client.write((buffer.writeInt32LE(num, 0), buffer))}, 1000).unref()})",
			"client.on('data', (data) => {console.log(`sum: ${data.readInt32LE()}`)})",
			"client.on('close', (data) => {console.log('close');client.destroy();})",
			"client.on('error', (err) => { console.log(`${err}`);})",
			"setTimeout(() => {client.destroy()}, 20000)",
		],
		"description": "Write Stream"
	},

	"tcpOtherUsers":{
		"prefix": "tcpOtherUsers",
		"body": [
			"--server.js--",
			"const net = require('net');",
			"let PORT = 4000;",
			"let sum = 0;",
			"let connections = new Map();",
			"let buffer = Buffer.alloc(4);",
			"let i=0;",
			"net.createServer((socket) => {",
			"socket.id = i++;",
			"connections.set(socket.id, 0);",
			"socket.on('data', (data) => {",
			"console.log(`${data.readInt32LE()}`);",
			"sum = data.readInt32LE() + connections.get(socket.id);",
			"connections.set(socket.id, sum);",
			"sum = 0;});",
			"let writer = setInterval(() => {",
			"buffer.writeInt32LE(connections.get(socket.id), 0);",
			"socket.write(buffer);}, 5000);",
			"socket.on('close', data => {clearInterval(writer);connections.delete(socket.id);});", 
			"socket.on('error', (e) => { connections.delete(socket.id);});}).listen(PORT);",
			"",
			"--client.js--",
			"const net = require('net')",
			"const PORT = 4000",
			"let client = new net.Socket()",
			"let buffer = new Buffer.alloc(4);",
			"let num = isNaN(process.argv[2]) ? process.exit() : process.argv[2];",
			"client.connect(PORT, () => {setInterval(() => {client.write((buffer.writeInt32LE(num, 0), buffer))}, 1000).unref()})",
			"client.on('data', (data) => {console.log(`sum: ${data.readInt32LE()}`)})",
			"client.on('close', (data) => {console.log('close');client.destroy();})",
			"client.on('error', (err) => { console.log(`${err}`);})",
			"setTimeout(() => {client.destroy()}, 20000)",
		],
		"description": "Write Stream"
	},

	"wJSON":{
		"prefix": "wJSON",
		"body": [
			"--server.js--",
			"const WebSocket = require('ws');",
			"const wss = new WebSocket.Server({port:4000, host:'localhost'});",
			"let n = 0;",
			"wss.on('connection', (ws)=>{let x; ",
			"ws.on('message', (data)=>{x =  JSON.parse(data);console.log('on message: ', x);}); ",
			"setInterval(()=> {ws.send(JSON.stringify({server: n++, client: x.client, timestamp: new Date().toDateString()}))}, 5000);});",
			"wss.on('error', (e)=>{console.log('wss server error', e)});",
			"",
			"--client.js--",
			"const WebSocket = require('ws');",
			"const ws = new WebSocket('ws://localhost:4000');",			
			"let parm = process.argv[2];",
			"let prfx = typeof parm == 'undefined' ? 'ClientName' : parm;",
			"ws.on('open', ()=>{",
			"ws.on('message', (data)=>{data =  JSON.parse(data);",
			"console.log('on message: ', data);}); ",
			"setInterval(()=>{ ws.send(JSON.stringify({client: prfx, t: new Date().toDateString()})) }, 3000)});",
			"ws.on('error', (e)=>{console.log('wss server error', e)});",
		],
		"description": "Write Stream"
	},

	"RPC":{
		"prefix": "RPC",
		"body": [
			"--server.js--",
			"const rpcWSS = require('rpc-websockets').Server",
			"let server =  new rpcWSS({port: 4000, host:'localhost'});",
			"function factorial(n) {return (n > 1) ? n * factorial(n - 1) : 1;} ",
			"server.setAuth((l) => {return (l.login === 'admin' && l.password === 'admin') });  ",
			"server.register('square', (params) => {return params.length === 2 ? params[0] * params[1] : Math.pow(params[0],2) * Math.PI;}).public(); ",
			"server.register('fact', (param) => {if (param.length === 1) return factorial(param) else return [1];}).protected();",
			"",
			"--client.js--",
			"const rpcWSC = WebSocket =  require('rpc-websockets').Client;",
			"let ws = new rpcWSC('ws://localhost:4000');",
			"ws.on('open', () => { ",
			"ws.call('square', [3]).then((r)=>{console.log('square(3) = ', r);}); ",
			"ws.call('square', [5, 4]).then((r)=>{console.log('square(5,4) = ', r);}); ",
			"ws.login({login: 'admin', password: 'admin'}).then((login) => { ",
			"ws.call('fact',[0]).catch((e)=>{console.log('catch fact: ',e)}).then((r)=>{console.log('fact(0) = ', r);}); ",
			"ws.call('fact', [10]).catch((e)=>{console.log('catch fact: ',e)}).then((r)=>{console.log('fact(10) = ', r);});})});",
			"",
			"--client2.js--",
			"const async= require('async');",
			"const rpcWSC = require('rpc-websockets').Client; ",
			"let ws = new rpcWSC('ws://localhost:4000'); ",
			"let h = (x=ws) => async.parallel({ ",
			"square: (cb)=>{ws.call('square', [3]).catch((e)=>cb(e,null)).then((r)=>cb(null,r));},",
			"square2: (cb)=>{ws.call('square', [5, 4]).catch((e)=>cb(e,null)).then((r)=>cb(null,r));}, ",
			"fact: (cb) =>{ws.login({login: 'admin', password: 'admin'}).then((login) => {ws.call('fact', [0]).catch((e)=>cb(e,null)).then((r)=>cb(null,r));})}, ", 
			"fact3: (cb) =>{ws.login({login: 'admin', password: 'admin'}).then((login) => {ws.call('fact', [10]).catch((e)=>cb(e,null)).then((r)=>cb(null,r));})} ",
			"}, (error, result) => { ",
			"if(error) console.log('error =', error); ",
			"else console.log('result =', result); ",
			"ws.close();}); ",
			"ws.on('open', h);",
			"",
			"--client3.js--",
			"const rpcWSC = WebSocket =  require('rpc-websockets').Client; ",
			"let ws = new rpcWSC('ws://localhost:4000'); ",
			"ws.on('open', () => {ws.login({login: 'admin', password: 'admin'}).then(async (login) => { await calc() })}); ",
			"const reducer = (previousValue, currentValue) => previousValue + currentValue; ",
			"async function calc() {console.log('Result: ', await ws.call('square', [3])+ (await ws.call('fib', 7)).reduce(reducer) * await ws.call('mul', [2, 4, 6]));}",
		],
		"description": "Write Stream"
	},

	"eventRPC":{
		"prefix": "eventRPC",
		"body": [
			"--server.js--",
			"const rpcServer = require('rpc-websockets').Server; ",
			"const eventSocket = new rpcServer({ port: 4000, host: 'localhost'});  ", 
			"eventSocket.event('A');eventSocket.event('B');eventSocket.event('C'); ",
			"console.log('Enter A, B or C'); ",
			"process.stdin.on('readable', () => { ",
			"while ((chunk  = process.stdin.read())!== null) { let input = chunk.toString().trim(); ",
			"if (input === 'A' || input === 'B' || input === 'C') {eventSocket.emit(input);}}});",
			"",
			"--client.js--",
			"const rpc = require('rpc-websockets').Client; ",
			"const eventSocket = new rpc('ws://localhost:4000'); ",
			"eventSocket.on('open', () => {eventSocket.subscribe('A');eventSocket.on('A', () => console.log('A!\n'));});",
			"",
			"--client2.js--",
			"const rpc = require('rpc-websockets').Server; ",
			"let server = new rpc({port: 4000, host: 'localhost'}); ",
			"server.register('A', (params) => {console.log('A')}).public();  ",
			"server.register('B', (params) => {console.log('B')}).public(); ",
			"server.register('C', (params) => {console.log('C')}).public();",
			"",
			"--client3.js--",
			"const rpcWSC = require('rpc-websockets').Client; ",
			"let ws = new rpcWSC('ws://localhost:4000/'); ", 
			"ws.on('open', () => {console.log('Enter A, B or C'); ",
			"process.stdin.on('readable', () => { ",
			"while ((chunk  = process.stdin.read())!== null) { let input = chunk.toString().trim(); ",
			"if (input === 'A' || input === 'B' || input === 'C') {ws.notify(input);}}});});",
		],
		"description": "Write Stream"
	},

	"apl-x-www":{
		"prefix": "apl-x-www",
		"body": [
			"const http = require('http');",
			"const query = require('querystring'); ",
			"const url = require('url'); ",
			"http.createServer(function(request, response) { ",
			"let data = ''; ",
			"request.on('data', chunk => {data += chunk.toString();}) ",
			"request.on('end', () => { ",
			"response.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'}); ",
			"response.end('x = '+query.parse(data).x+'; y = '+ query.parse(data).y+'; s = '+query.parse(data).s);});}).listen(5000); ",
			"let param = query.stringify({x: 2, y: 8, s: 'aa'}); ",
			"let options = {host: 'localhost',path: '/',port: 5000,method: 'POST', ",
			"headers: {'Content-Type': 'application/x-www-form-urlencoded','Accept': 'application/x-www-form-urlencoded'}}; ",
			"let request = http.request(options, (res) => { ",
			"console.log('Response status: ',res.statusCode); ",
			"let data= ''; ",
			"res.on('data', (chunk) => {console.log('body: ',data += chunk.toString('utf8'));});}); ",
			"request.write(param); ",
			"request.end();",
		],
		"description": "Write Stream"
	},

	"upload-multiparty":{
		"prefix": "upload-multiparty",
		"body": [
			"var http = require('http');",
			"let fs = require('fs');",
			"let mp = require('multiparty'); ",
			"http.createServer(function(req, res) { let form = new mp.Form({uploadDir: './st'}); ", 
			"form.on('field', (name, value) => {});form.on('file', (name, file) => {}); ",
			"form.on('error', (err) => {res.writeHead(200, {'Content-Type' : 'text/plain; charset=utf-8'});res.end(`${err}`);}); ",
			"form.on('close', () => {res.writeHead(200, {'Content-Type' : 'text/plain; charset=utf-8'});res.end('Файл получен');}); ",
			"form.parse(req);}).listen(5000); ",
			"let bound = '---------------------------';  ",
			"let options = {host: 'localhost',path: '/',port: 5000,method: 'POST', ",
			"headers: {'content-type': 'multipart/form-data; boundary=' + bound}} ",
			"const req = http.request(options, res => { ",
			"console.log(`${res.statusCode}: ${res.statusMessage}`); ",
			"let data = ''; ",
			"res.on('data', chunk => {data += chunk.toString('utf8');}); ",
			"res.on('end', () => {console.log(`\n${data}`);});}); ",
			"req.write('--' + bound + '\r\n'); ",
			"req.write('Content-Disposition: form-data; name='file'; filename='MyFile.txt'\r\n\r\n'); ",
			"req.write(fs.readFileSync('MyFile.txt') + '\r\n'); ",
			"req.write('--' + bound + '--\r\n'); ",
			"req.end();",
		],
		"description": "Write Stream"
	},

	"porti-multiparty":{
		"prefix": "porti-multiparty",
		"body": [
			"var http = require('http');",
			"let fs = require('fs');",
			"http.createServer(function(request, response) { ",
			"response.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'}); ",
			"let png = ''; ",
			"request.on('data', (chunk) => { png += chunk.toString();}); ",
			"request.on('end', () => {console.log('request.on(end) = ', png.length)});}).listen(5000); ",
			"let bound = '---------------------------'; ",
			"let body = `${bound}\r\n`; ",
			"body += 'Content-Disposition: form-data; name='file'; filename='MyFile.png'\r\n'; ",
			"body += 'Content-Type: application/octet-stream\r\n\r\n'; ",
			"let options = {host: 'localhost',path: '/',port: 5000,method: 'POST', ",
			"headers: {'content-type':'multipart/form-data; boundary='+bound}}; ",
			"let request = http.request(options, (response) => {let data = ''; ",
			"response.on('data', (chunk) => {data += chunk;});}); ",
			"request.write(body); ",
			"let stream = new fs.ReadStream('MyFile.png'); ",
			"stream.on('data', (chunk) => {request.write(chunk); console.log(Buffer.byteLength(chunk));}); ",
			"stream.on('end', () => {request.end(`\r\n${bound}\r\n`);}); ",
		],
		"description": "Разработайте приложение (клиент) 09-07, предназначенное для отправки POST-запроса с вложенным файлом MyFile.png (multipart/form-data). "
	},

	"theory":{
		"prefix": "theory",
		"body": [
			"-----------глобальные обьекты",
			" process.stdout.write('Hello World!');" ,
			"process.stdin.on('data', function (data) {",
			"console.log(data.toString());});",
			"process.stderr.write('Hello from stderr!');",
			"-----------callback",
			"function callback(err, data) {",
			"if (err) {console.error(err);",
			"} else {console.log(data);}}",
			"------------promise",
			"let promise = new Promise(function(resolve, reject) {",
			"setTimeout(() => resolve('result'), 1000);",
			"if (2<3) {reject('error');}});",
			"promise.then((result) => {console.log(result);});",
			"------------async/await",
			"async function f() {",
			"let func = async() => {",
			"try { let m = await promise;",
			"console.log(m);} catch (err) {console.log(err);}}}",
			"func();",
			"------------eventemmiter",
			"const util = require('util');",
			"const EventEmitter = require('events');",
			"function MyEmitter() {",
			"EventEmitter.call(this);}",
			"util.inherits(MyEmitter, EventEmitter);"
			"exports.MyEmitter = MyEmitter;",
			"let myEmitter = new MyEmitter();",
			"myEmitter.on('event', () => {console.log('an event occurred!');});",
			"myEmitter.emit('event');",
			"------------param module",
			"var modules = {A: require('./A'),B: require('./B'),C: require('./C')} ",
			"function X(impl) { ",
			"if(impl in modules)return new modules[impl]; ",
			"else throw new Error('Unknown impl: ' + impl);} ",
			"module.exports = X; ",			
			"var foo = new X('A'); ",
			"foo.method(); ",
			"// => 'A' ",
			"var bar = new X('B'); ",
			"bar.method()",
			"// => 'B'",
			"------------es6",
			"--export after обьявления",
			"var num=10",
			"function multipy(a){return num*a:}",
			"export {multipy as default}",
			"--именованый export after обьявления",
			"export {multipy, num}",
			"import {multipy, num} from 'module'",
			"import * as module from 'module'",
			"--именованый export before обьявления",
			"export function multipy(a){return num*a:}",
			"import {multipy} from 'module'",
			"--динамический import",
			"import('module').then(module => {",
			"console.log(module.multipy(2));",
		],
		"description": "Разработайте приложение (клиент) 09-07, предназначенное для отправки POST-запроса с вложенным файлом MyFile.png (multipart/form-data). "
	},

	"axios":{
		"prefix": "axios",
		"body": [
			"- stringify(…)=> new URLSearchParams(…).toString()",
			"- parse(…)=> new URLSearchParams(…).get(…)",
			"const axios = require('axios');",
			"let params = new URLSearchParams({x:3,y:12}).toString();",
			"function httpRequest(){ return axios({",
			"method: 'get',",
			"url: 'http://localhost:3000/?${params}',})",
			"--for post"
			"url: 'http://localhost:3000/',})",
			"data:{x:3,y:12}});",
			"httpRequest().then((response) => {console.log(response.data);})",
			"catch((error) => {console.log(error);});",
		],
		"description": "Write Stream"
	},
	"opred":{
		"prefix": "opred",
		"body": [
			"HTTP-протокол – протокол передачи данных прикладного уровня, ассиметричный (сообщения от клиента к серверу и от сервера к клиенту разные). Всегда подразумевает пару request/response. ",
			"Относится к протоколу, который не помнит своего состояния. В запросе и ответе нет никаких ссылок на предыдущий и последующий ответ и запрос.  ",
			"Каждый запрос-ответ – новый жизненный цикл HTTP (stateless протокол). ",
			"HTTP: основные свойства-  версии HTTP/1.1 – действующий (текстовый), HTTP/2 – черновой (не распространен, бинарный);-   два типа абонентов: клиент и сервер;-   два типа сообщений: request и response;-   от клиента к серверу – request;-   от сервера к клиенту – response;-   на один request всегда один response, иначе ошибка;-   одному response всегда один request,  иначе ошибка;-   TCP-порты: 80 для http, 443 для https;-   для адресации используется URI или URN;",			
			"Request:-метод; -URI;-версия протокола (HTTP/1.1);-заголовки(пары:имя/заголовок);-параметры(пары:имя/заголовок);-расширение. ",
			"Response:-версия протокола (HTTP/1.1);-код состояния (1xx, 2xx, 3xx, 4xx, 5xx);-пояснение к коду состояния;-заголовки(пары:имя/заголовок)-расширение",
			"*OPTIONS – OPTIONS используется для описания параметров соединения с ресурсом.*GET –Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.*HEAD – HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.*POST – POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.*PUT – загрузки содержимого на указ.URI (не было – созд; есть – измен.). PUT заменяет все текущие представления ресурса данными запроса.*DELETE – DELETE удаляет указанный ресурс*TRACE –  TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.",
			"Заголовки:HTTP заголовки — это часть HTTP сообщения, в которой содержатся различные параметры, которые используются для правильного построения web-страницы",
			"Код состояния:-   1xx: информационные сообщения;-   2xx: успешный ответ;-   3xx: переадресация;-   4xx: ошибка клиента;-   5xx: ошибка сервера.", 
			"Веб-приложение — клиент-серверное приложение, в котором клиент взаимодействует с веб-сервером при помощи браузера",
			"Структура: 1. 1 клиент – 1 сервер 2. 1 клиент – несколько серверов 3. Несколько клиентов – 1 сервер4. Клиенты  - промежуточный сервер – сервер",
			"Операция называется асинхронной, если ее выполнение  осуществляется в 2 фазы: 1) заявка на исполнение; 2) получение результата; при этом участвуют два механизма: A-механизм, формирующий заявку и потом  получающий результат; B-механизм, получающий заявку от A, исполняющий операцию и отправляющий результат A; продолжительность исполнения операции B-механизмом, как правило, непредсказуемо; в то время пока B-механизм исполняет операцию, А-механизм выполняет собственную работу. ",
			" ",
			"--------Web-сервер.",
			"Веб-сервер — сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными.Ресурсы Оперативная память, процессорное время.",
			"О блокировании говорят, когда выполнение js-кода приостановлено до тех пор пока не завершится работа сторонней операции.Блокирующие методы выполняются синхронно, а неблокирующие асинхронно.",
			"Решение- Многопоточность (огран кол-во потоков, т.к. каждый требует доп. памяти) – в Apache- асинхр прогр – паттерн Reactor – в Nginx",
			"Reactor – шаблон проектирования. Используется при обработке параллельных запросов к сервису. Сервисный обработчик разбирает прибывшие запросы и синхронно перенаправляет их на соответствующие обработчики запросов",
			"Параллелизм — подкласс конкурентности: перед выполнением нескольких одновременных задач вам нужно их сначала правильно организовать.",
			"Закон Амдала - иллюстрирует ограничение роста производительности вычислительной системы с увеличением количества вычислителей. «В случае, когда задача разделяется на несколько частей, суммарное время её выполнения на параллельной системе не может быть меньше времени выполнения самого медленного фрагмента»Согласно этому закону, ускорение выполнения программы за счёт распараллеливания её инструкций на множестве вычислителей ограничено временем, необходимым для выполнения её последовательных инструкций.",
			"",
			"--------Платформа Node.js,",
			"  NODEJS: программная платформа для разработки  серверных web-приложений на языке JS/V8.",
			"Свойства-   основан на Chrome V8;-   среда (контейнер) исполнения приложений на JavaScript;-   поддерживает механизм асинхронности;-   ориентирован на события;-   однопоточный (код приложения исполняется только в одном потоке, один стек вызовов); обычно в серверах для каждого соединения создается свой поток, в Node.js все соединения обрабатываются в одном JS-потоке;-   не блокирует выполнение кода при вводе/выводе (в файловой системе до 4х одновременно);-   в состав Node.js входят инструменты: npm – пакетный менеджер; gyp - Python-генератор проектов; gtest – Google фреймворк для тестирования С++ приложений; ",
			"Структура Core – собраны модули для работы с сетевыми запросами, V8 – компиляция JS-кода в машинный, libuv – взаимодействие с ОС(EventLoop тоже там). использует библиотеки: V8 – библиотека V8 Engine, libuv – библиотека для абстрагирования неблокирующих операций ввода/вывода (представляет собой обертку над epoll, kqueue, IOCP); llhttp – легковесный парсер http-сообщений (написан на C и не выполняет никаких системных вызовов); c-ares - библиотека для работы с DNS; OpenSSL – библиотека для криптографии; zlib – сжатие и распаковка. ",
			"",
		],
		"description": "Write Stream"
	},
}